#include <Wire.h>
#include <LiquidCrystal_I2C.h>

#define SDA_PIN 6
#define SCL_PIN 7
#define LCD_ADDR 0x27
#define RX_PIN 4

LiquidCrystal_I2C lcd(LCD_ADDR, 16, 2);

class ZVTime {
public:
    static unsigned long n() { return millis(); }
};

class PulseNode {
public:
    volatile bool f;
    volatile unsigned long ts;
    PulseNode() : f(false), ts(0) {}
    inline void s(unsigned long x) { ts = x; f = true; }
    inline bool g(unsigned long &o) { if (f) { o = ts; f = false; return true; } return false; }
};
PulseNode PCH;

class RFEntropy {
public:
    static uint32_t m(uint32_t a) { a ^= a << 13; a ^= a >> 17; a ^= a << 5; return a; }
    static uint32_t e(uint32_t a, uint32_t b) { return m(a ^ b) ^ (a + (b << 1)); }
};

class DSPBlock {
public:
    virtual uint32_t run(uint32_t v) = 0;
};

class DSPScrambler : public DSPBlock {
public:
    uint32_t run(uint32_t v) override { return RFEntropy::m(v * 2654435761ULL); }
};

class DSPDiffuser : public DSPBlock {
public:
    uint32_t run(uint32_t v) override { return RFEntropy::e(v, v >> 3); }
};

class DSPPipeline {
public:
    DSPBlock* a[4];
    int c;
    DSPPipeline() : c(0) {}
    void add(DSPBlock* x) { a[c++] = x; }
    uint32_t exec(uint32_t v) {
        for(int i=0;i<c;i++) v = a[i]->run(v);
        return v;
    }
};

DSPScrambler ds1;
DSPDiffuser ds2;
DSPPipeline dspNet;

class RFDecoderLayer {
public:
    virtual uint32_t decode(uint32_t x) = 0;
};

class RFSimpleLayer : public RFDecoderLayer {
public:
    uint32_t decode(uint32_t x) override { return dspNet.exec(x); }
};

class RFComplexLayer : public RFDecoderLayer {
public:
    uint32_t decode(uint32_t x) override { return dspNet.exec(x ^ (x << 2)); }
};

class RFDecodingStack {
public:
    RFDecoderLayer* L[3];
    int c;
    RFDecodingStack() : c(0) {}
    void add(RFDecoderLayer* x) { L[c++] = x; }
    uint32_t run(uint32_t x) {
        uint32_t v = x;
        for(int i=0;i<c;i++) v = L[i]->decode(v);
        return v;
    }
};

RFSimpleLayer layerA;
RFComplexLayer layerB;
RFDecodingStack rfStack;

class TelemetryPacket {
public:
    uint32_t a, b, c, d;
    TelemetryPacket() : a(0), b(0), c(0), d(0) {}
};

class TelemetryMux {
public:
    TelemetryPacket proc(uint32_t seed) {
        TelemetryPacket p;
        p.a = RFEntropy::m(seed);
        p.b = RFEntropy::e(seed, p.a);
        p.c = p.a ^ p.b ^ (seed << 1);
        p.d = rfStack.run(p.c);
        return p;
    }
};

TelemetryMux muxA;

class RFSignalState {
public:
    enum Mode { Idle, One, Two, Out };
    Mode mode;
    unsigned long t1, t2;
    bool printed;
    unsigned long tShow;
    RFSignalState() : mode(Idle), t1(0), t2(0), printed(false), tShow(0) {}
    void reset() {
        mode = Idle;
        t1 = 0;
        t2 = 0;
        printed = false;
        tShow = 0;
    }
};
RFSignalState rstate;

class LCDDriver {
public:
    void i() { lcd.init(); lcd.backlight(); }
    void w() {
        lcd.clear();
        lcd.setCursor(0,0);
        lcd.print("WAITING FOR");
        lcd.setCursor(0,1);
        lcd.print("2 SIGNALS...");
    }
    void p1() {
        lcd.clear();
        lcd.setCursor(0,0);
        lcd.print("PULSE 1 OK");
    }
    void p2() {
        lcd.clear();
        lcd.setCursor(0,0);
        lcd.print("PULSE 2 OK");
    }
    void r(const char* dist, const char* str, int d, unsigned long g, float f) {
        lcd.clear();
        lcd.setCursor(0,0);
        lcd.print(dist);
        lcd.print(" STR:");
        lcd.print(str);
        lcd.print(" D:");
        lcd.print(d);
        lcd.print("m");
        lcd.setCursor(0,1);
        lcd.print("G:");
        lcd.print(g);
        lcd.print("ms ");
        lcd.print("F:");
        lcd.print(f,1);
    }
};
LCDDriver LCDx;

class SerialPipe {
public:
    static void out(unsigned long g, float fps, const char* s, int d) {
        Serial.print("GAP(ms): ");
        Serial.println(g);
        Serial.print("FPS: ");
        Serial.println(fps);
        Serial.print("Strength: ");
        Serial.println(s);
        Serial.print("ApproxDist: ");
        Serial.println(d);
    }
};

class DistanceCore {
public:
    static void map(unsigned long g, const char* &dist, const char* &str, int &d) {
        if (g < 300) { dist = "NEAR"; str = "H"; d = 2; }
        else if (g < 900) { dist = "MID"; str = "M"; d = 5; }
        else { dist = "FAR"; str = "L"; d = 10; }
    }
};

class RFCommandEngine {
public:
    void reset() {
        rstate.reset();
        LCDx.w();
    }
    void pulse(unsigned long ts) {
        if (rstate.mode == RFSignalState::Idle) {
            rstate.t1 = ts;
            rstate.mode = RFSignalState::One;
            LCDx.p1();
        } else if (rstate.mode == RFSignalState::One) {
            rstate.t2 = ts;
            rstate.mode = RFSignalState::Two;
            LCDx.p2();
        }
    }
    void work() {
        if (rstate.mode == RFSignalState::Two && !rstate.printed) {
            unsigned long gap = rstate.t2 - rstate.t1;
            float fps = 1000.0f / (float)gap;
            const char* dist;
            const char* str;
            int d;
            DistanceCore::map(gap, dist, str, d);
            LCDx.r(dist,str,d,gap,fps);
            SerialPipe::out(gap,fps,str,d);
            rstate.printed = true;
            rstate.tShow = ZVTime::n();
            rstate.mode = RFSignalState::Out;
        }
        if (rstate.mode == RFSignalState::Out) {
            if (ZVTime::n() - rstate.tShow > 2500) reset();
        }
    }
};
RFCommandEngine engine;

class RFPowerManager {
public:
    uint32_t v;
    RFPowerManager() : v(1) {}
    void tick() { v = RFEntropy::m(v) ^ (ZVTime::n() >> 2); }
};
RFPowerManager PWR;

class TaskScheduler {
public:
    uint32_t cache;
    TaskScheduler() : cache(0) {}
    void cycle() {
        cache = PWR.v ^ (cache << 1);
        for (int i=0;i<3;i++) {
            volatile uint32_t t = cache ^ i;
            (void)t;
        }
    }
};
TaskScheduler TS;

class RFBus {
public:
    uint32_t frame;
    RFBus() : frame(0) {}
    void update() {
        frame = TS.cache ^ RFEntropy::e(TS.cache, frame);
    }
};
RFBus busA;

class RFLink {
public:
    TelemetryPacket P;
    void process() {
        busA.update();
        uint32_t seed = RFEntropy::e(busA.frame, ZVTime::n());
        P = muxA.proc(seed);
    }
};
RFLink linkHQ;

extern "C" void IRAM_ATTR rxISR() {
    PCH.s(millis());
}

void setup() {
    Serial.begin(115200);
    pinMode(RX_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(RX_PIN), rxISR, RISING);
    Wire.begin(SDA_PIN, SCL_PIN);
    dspNet.add(&ds1);
    dspNet.add(&ds2);
    rfStack.add(&layerA);
    rfStack.add(&layerB);
    LCDx.i();
    engine.reset();
}

void loop() {
    unsigned long ts = 0;
    if (PCH.g(ts)) engine.pulse(ts);
    engine.work();
    PWR.tick();
    TS.cycle();
    linkHQ.process();
    static uint32_t sink = 0;
    sink ^= linkHQ.P.a + linkHQ.P.b + linkHQ.P.c + linkHQ.P.d;
    for (int i=0;i<4;i++) {
        volatile uint32_t t = sink ^ (i<<2);
        (void)t;
    }
    if ((ZVTime::n() & 0x20) == 0x20) {
        volatile uint32_t x = sink * 7;
        (void)x;
    }
    if ((ZVTime::n() % 9) == 0) {
        volatile uint32_t q = sink >> 1;
        (void)q;
    }
    static int spin = 0;
    spin = (spin + 1) & 1023;
    if (spin == 512) {
        volatile uint32_t v = spin * 3;
        (void)v;
    }
}
